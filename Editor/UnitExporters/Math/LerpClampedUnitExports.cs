using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEditor;
using UnityEngine;

namespace UnityGLTF.Interactivity.Export
{
    public class LerpClampedUnitExports : IUnitExporter
    {
        [InitializeOnLoadMethod]
        private static void Register()
        {
            InvokeUnitExport.RegisterInvokeExporter(typeof(Mathf), nameof(Mathf.Lerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float")));
            InvokeUnitExport.RegisterInvokeExporter(typeof(Vector2), nameof(Vector2.Lerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float2")));
            InvokeUnitExport.RegisterInvokeExporter(typeof(Vector3), nameof(Vector3.Lerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float3")));
            InvokeUnitExport.RegisterInvokeExporter(typeof(Vector4), nameof(Vector4.Lerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float4")));
            InvokeUnitExport.RegisterInvokeExporter(typeof(Quaternion), nameof(Quaternion.Lerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float4")));
            
            // TODO: correct Slerp, currently we use Mix  
            InvokeUnitExport.RegisterInvokeExporter(typeof(Vector3), nameof(Vector3.Slerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float3")));
            InvokeUnitExport.RegisterInvokeExporter(typeof(Quaternion), nameof(Quaternion.Slerp), new LerpClampedUnitExports(GltfInteractivityTypeMapping.TypeIndexByGltfSignature("float4")));
        }

        public Type unitType { get => typeof(InvokeMember); }
        private int gltfType;
        
        public LerpClampedUnitExports(int gltfType)
        {
            this.gltfType = gltfType;
        }
        
        public void InitializeInteractivityNodes(UnitExporter unitExporter)
        {
            var unit = unitExporter.unit as InvokeMember;
            
            GenericUnitExport.TryGetAutoGeneratedSchema("math/saturate", out var saturateSchema);
            var saturateNode = unitExporter.CreateNode(saturateSchema);
            saturateNode.OutValueSocket["value"].expectedType = ExpectedType.GtlfType(gltfType);

            GenericUnitExport.TryGetAutoGeneratedSchema("math/mix", out var mixSchema);
            var mixNode = unitExporter.CreateNode(mixSchema);
            mixNode.OutValueSocket["value"].expectedType = ExpectedType.GtlfType(gltfType);

            // Added C value to A port of saturate node
            unitExporter.MapInputPortToSocketName(unit.valueInputs[2], "a", saturateNode);
            // Add saturated value to C port of mix node
            unitExporter.MapInputPortToSocketName("value", saturateNode, "c", mixNode);
            
            unitExporter.MapInputPortToSocketName(unit.valueInputs[0], "a", mixNode);
            unitExporter.MapInputPortToSocketName(unit.valueInputs[1], "b", mixNode);
            
            unitExporter.MapValueOutportToSocketName(unit.result, "value", mixNode);
            unitExporter.ByPassFlow(unit.enter, unit.exit);
         }
        
    }
}